Object subclass: #DiceBag	instanceVariableNames: 'dice'	classVariableNames: ''	poolDictionaries: ''	category: 'MyDice'!!DiceBag commentStamp: 'VeronikaLarionova 10/23/2018 22:06' prior: 0!I represent a simple bag where you can store dice.The bag is responsible to store the dice and also it is possible to roll dice in the bag.#addDie: 	allows to add a die into the bag.#diceCount	tells how many dice are in the bag#roll 		rolls all the content of the bag and tell the final sum of numbers		    Instance Variables	dice:		<Bag>    Implementation Points!!DiceBag methodsFor: 'adding' stamp: 'VeronikaLarionova 10/26/2018 00:54'!addDie: aDie	"adds the die into the bag"	self dice add: aDie! !!DiceBag methodsFor: 'as yet unclassified' stamp: 'VeronikaLarionova 10/26/2018 00:51'!diceCount	"provides the total number of dice in the bag"	^ self dice size! !!DiceBag methodsFor: 'as yet unclassified' stamp: 'VeronikaLarionova 10/26/2018 00:49'!countOf: aDie	"provides the number of specific die in the bag"	^ self dice occurrencesOf: aDie! !!DiceBag methodsFor: 'printing' stamp: 'VeronikaLarionova 11/4/2018 17:41'!printOn: aStream	| strings |	strings := (self dice		collect: [ :value | (self countOf: value) asString , 'D' , value faces asString ])		asOrderedCollection.	aStream << (' + ' join: strings)! !!DiceBag methodsFor: 'actions' stamp: 'VeronikaLarionova 11/4/2018 17:49'!roll	"method rolls with all the dice in the bag and returns the sum of all bag's rolls"	| sum |	self dice ifEmpty: [ ^ 0 ].	sum := 0.	self dice do: [ :die | sum := sum + die roll ].	^ sum! !!DiceBag methodsFor: 'initialization' stamp: 'VeronikaLarionova 11/4/2018 17:52'!initialize	super initialize.	"dice:= Bag new"! !!DiceBag methodsFor: 'accessing' stamp: 'VeronikaLarionova 11/4/2018 17:53'!dice	dice ifNil: [ dice := Bag new ].	^ dice! !!DiceBag methodsFor: 'accessing' stamp: 'VeronikaLarionova 10/22/2018 19:12'!dice: aBagdice := aBag.! !!DiceBag methodsFor: 'arithmetic' stamp: 'VeronikaLarionova 11/4/2018 17:41'!+ aDiceBag	"sums the content of 2 bags and returns the new one"	| newBag |	newBag := DiceBag new dice: self dice , aDiceBag dice.	^ newBag! !!DiceBag methodsFor: 'testing' stamp: 'VeronikaLarionova 10/26/2018 00:52'!contains: aDie"Returns the boolean that tells if the die is in the bag"^ self dice includes: aDie.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DiceBag class	instanceVariableNames: ''!!DiceBag class methodsFor: 'instance creation' stamp: 'VeronikaLarionova 10/23/2018 23:54'!with: aBagDiceBag new dice: aBag.! !TestCase subclass: #DiceBagTest	instanceVariableNames: 'diceBag diceBag2'	classVariableNames: ''	poolDictionaries: ''	category: 'MyDice'!!DiceBagTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/26/2018 00:55'!testDiceCount	"self run: #testDiceCount"	self assert: diceBag diceCount = 3.	self assert: diceBag2 diceCount = 4.	self deny: (diceBag diceCount > 3 or: [ diceBag diceCount < 3 ]).	diceBag		addDie: (Die withFaces: 11);		addDie: (Die withFaces: 3).	self assert: diceBag diceCount = 5! !!DiceBagTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/26/2018 00:55'!testPrintOn	"self run: #testPrintOn"	self assert: (diceBag printString includesSubstring: '1D6').	self assert: (diceBag printString includesSubstring: '1D4').	self assert: (diceBag printString includesSubstring: '1D10').	diceBag		addDie: (Die withFaces: 4);		addDie: (Die withFaces: 4).	self assert: (diceBag printString includesSubstring: '3D4').	self deny: (diceBag printString includesSubstring: '2D6').	self deny: (diceBag printString includesSubstring: '1D11')! !!DiceBagTest methodsFor: 'tests' stamp: 'VeronikaLarionova 11/4/2018 17:50'!testRoll	"self run: #testRoll"	self assert: (DiceBag new roll) equals: 0.	100 timesRepeat: [ self assert: (diceBag roll between: 1 and: 20) ]! !!DiceBagTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/26/2018 00:55'!testCountOf	"self run: #testCountOf"	self assert: (diceBag countOf: Die new) = 1.	diceBag addDie: (Die withFaces: 4).	self assert: (diceBag countOf: (Die withFaces: 4)) = 2! !!DiceBagTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/22/2018 19:34'!testSum	"self run: #testSum"	| summedBag |	summedBag := diceBag + diceBag2.	self assert: summedBag diceCount = 7.	self assert: ((summedBag contains: Die new) and: (summedBag countOf: Die new) = 3).	self		assert:			((summedBag contains: (Die withFaces: 4))				and: (summedBag countOf: (Die withFaces: 4)) = 2).	self		assert:			((summedBag contains: (Die withFaces: 10))				and: (summedBag countOf: (Die withFaces: 10)) = 1).	self		assert:			((summedBag contains: (Die withFaces: 11))				and: (summedBag countOf: (Die withFaces: 11)) = 1).	self deny: (summedBag contains: (Die withFaces: 3)).	self deny: (summedBag contains: (Die withFaces: 1000)).	self deny: (summedBag countOf: Die new) = 2! !!DiceBagTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/26/2018 00:55'!testContains	"self run: #contains"	self assert: (diceBag contains: Die new).	self assert: (diceBag contains: (Die withFaces: 4)).	self assert: (diceBag contains: (Die withFaces: 10)).	self deny: (diceBag contains: (Die withFaces: 11)).	self deny: (diceBag contains: (Die withFaces: 5)).	self assert: (diceBag2 contains: Die new).	self assert: (diceBag2 contains: (Die withFaces: 4)).	self deny: (diceBag2 contains: (Die withFaces: 10)).	self assert: (diceBag2 contains: (Die withFaces: 11)).	self deny: (diceBag2 contains: (Die withFaces: 5))! !!DiceBagTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/26/2018 00:55'!testAddDie	"self run: #testAddDie"	self assert: (diceBag contains: (Die withFaces: 4)).	diceBag addDie: Die new.	self assert: (diceBag contains: Die new).	self assert: (diceBag countOf: Die new) = 2! !!DiceBagTest methodsFor: 'initialization' stamp: 'VeronikaLarionova 10/22/2018 19:16'!setUp	diceBag := DiceBag new.	diceBag		addDie: (Die withFaces: 4);		addDie: (Die withFaces: 10);		addDie: Die new.	diceBag2 := DiceBag new.	diceBag2		addDie: (Die withFaces: 4);		addDie: (Die withFaces: 11);		addDie: Die new;		addDie: Die new! !Object subclass: #Die	instanceVariableNames: 'faces'	classVariableNames: ''	poolDictionaries: ''	category: 'MyDice'!!Die commentStamp: '<historical>' prior: 0!I am a Die. The die has specific amount of faces and is able to roll and provide the number that randomly was provided.#faces#faces:#roll#withFaces    Instance Variables	faces:		<Number>!!Die methodsFor: 'printing' stamp: 'VeronikaLarionova 11/4/2018 17:54'!printOn: aStream	aStream << ('D' , self faces asString)! !!Die methodsFor: 'initialization' stamp: 'VeronikaLarionova 10/21/2018 14:16'!initializefaces := 6.! !!Die methodsFor: 'accessing' stamp: 'VeronikaLarionova 10/21/2018 14:00'!faces^faces! !!Die methodsFor: 'accessing' stamp: 'VeronikaLarionova 10/21/2018 14:09'!faces: aNumber"The method is responsible for setting the valid number of faces."(aNumber > 0) ifTrue: [ 	faces := aNumber.] ifFalse: [ 	self error: 'The number of faces should be greater than 0'.].! !!Die methodsFor: 'actions' stamp: 'VeronikaLarionova 10/21/2018 14:17'!roll"The metod is responsible for rolling the die and providing the number from interval <1,faces>"^ self faces atRandom.! !!Die methodsFor: 'comparing' stamp: 'VeronikaLarionova 10/26/2018 00:56'!< aDie	"does the comparsion of 2 dies. meant for sorting"	^ self faces < aDie faces! !!Die methodsFor: 'comparing' stamp: 'VeronikaLarionova 10/26/2018 00:57'!= aDie	"the comparsion function. eant for equaling each die"	^ self faces = aDie faces! !!Die methodsFor: 'comparing' stamp: 'VeronikaLarionova 10/22/2018 18:59'!hash^ faces hash.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Die class	instanceVariableNames: ''!!Die class methodsFor: 'as yet unclassified' stamp: 'VeronikaLarionova 10/21/2018 14:00'!withFaces: aNumber"Provides the parametrized instance of a die"^ self new faces: aNumber.! !TestCase subclass: #DieTest	instanceVariableNames: 'die'	classVariableNames: ''	poolDictionaries: ''	category: 'MyDice'!!DieTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/21/2018 14:23'!testPrintOn"self run: #testPrinting"self assert: die printString equals: 'D6'.die faces: 10.self assert: die printString equals: 'D10'.die faces: 42.self assert: die printString equals: 'D42'.! !!DieTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/21/2018 14:15'!testTheDefaultInitialization"self run: #testTheDefaultInitialization"self assert: die faces equals: 6.! !!DieTest methodsFor: 'tests' stamp: 'VeronikaLarionova 11/4/2018 17:51'!testRoll	"self run: #testRoll"	100 timesRepeat: [ self assert: (die roll between: 1 and: die faces) ]! !!DieTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/21/2018 14:14'!testSetterAndGetter"self run: #testSetterAndGetter"die faces: 6.self assert: die faces equals: 6.self should: [ die faces: 0 ] raise: Error.self should: [ die faces: -4 ] raise: Error.! !!DieTest methodsFor: 'initialization' stamp: 'VeronikaLarionova 11/4/2018 17:51'!setUp	"setting up the test"	die := Die new! !TestCase subclass: #IntegerExtentionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MyDice'!!IntegerExtentionTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/26/2018 00:42'!testD20	"self run: #testD20"	| diceBag die |	die := Die withFaces: 20.	diceBag := 2 D20.	self assert: diceBag diceCount = 2.	self assert: (diceBag contains: die).	self assert: (diceBag countOf: die) = 2.	diceBag := 1 D20.	self assert: diceBag diceCount equals: 1.	self assert: (diceBag contains: die).	self assert: (diceBag countOf: die) equals: 1.	diceBag := 5 D20.	self assert: diceBag diceCount = 5.	self assert: (diceBag contains: die).	self assert: (diceBag countOf: die) = 5.	diceBag := 10 D20.	self assert: diceBag diceCount = 10.	self assert: (diceBag contains: die).	self assert: (diceBag countOf: die) = 10! !!IntegerExtentionTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/26/2018 00:38'!testD4	"self run: #testD4"	| diceBag die|	die := Die withFaces: 4.		diceBag := 2 D4.	self assert: diceBag diceCount = 2.	self assert: (diceBag contains: die ).	self assert: (diceBag countOf: die) = 2.	diceBag := 1 D4.	self assert: diceBag diceCount = 1.	self assert: (diceBag contains: die ).	self assert: (diceBag countOf: die ) = 1.	diceBag := 5 D4.	self assert: diceBag diceCount = 5.	self assert: (diceBag contains: die ).	self assert: (diceBag countOf: die ) = 5.	diceBag := 10 D4.	self assert: diceBag diceCount = 10.	self assert: (diceBag contains: die ).	self assert: (diceBag countOf: die ) = 10! !!IntegerExtentionTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/23/2018 23:59'!testD"self run: #D"| bag |bag := 2D:4.self assert: (bag contains: (Die withFaces: 4)).self assert: ((bag countOf:  (Die withFaces: 4)) = 2).bag := (3D:3) + (4D:4).self assert:((bag contains: (Die withFaces:3) ) and: [bag contains: (Die withFaces: 4)]).self assert: (((bag countOf: (Die withFaces: 3)) = 3) and: [ (bag countOf: (Die withFaces: 4)) = 4])! !!IntegerExtentionTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/26/2018 00:36'!testD10	"self run: #testD10"	| diceBag die |	die := Die withFaces: 10.	diceBag := 2 D10.	self assert: diceBag diceCount = 2.	self assert: (diceBag contains: die).	self assert: (diceBag countOf: die) = 2.	diceBag := 1 D10.	self assert: diceBag diceCount equals: 1.	self assert: (diceBag contains: die).	self assert: (diceBag countOf: die) equals: 1.	diceBag := 5 D10.	self assert: diceBag diceCount = 5.	self assert: (diceBag contains: die).	self assert: (diceBag countOf: die) = 5.	diceBag := 10 D10.	self assert: diceBag diceCount = 10.	self assert: (diceBag contains: die).	self assert: (diceBag countOf: die) = 10! !!IntegerExtentionTest methodsFor: 'tests' stamp: 'VeronikaLarionova 10/26/2018 00:42'!testD6	"self run: #testD6"	| diceBag die |	die := Die withFaces: 6.	diceBag := 2 D6.	self assert: diceBag diceCount = 2.	self assert: (diceBag contains: die).	self assert: (diceBag countOf: die) = 2.	diceBag := 1 D6.	self assert: diceBag diceCount equals: 1.	self assert: (diceBag contains: die).	self assert: (diceBag countOf: die) equals: 1.	diceBag := 5 D6.	self assert: diceBag diceCount = 5.	self assert: (diceBag contains: die).	self assert: (diceBag countOf: die) = 5.	diceBag := 10 D6.	self assert: diceBag diceCount = 10.	self assert: (diceBag contains: die).	self assert: (diceBag countOf: die) = 10! !'From Pharo6.0 of 13 May 2016 [Latest update: #60546] on 4 November 2018 at 5:54:49.930266 pm'!!Integer methodsFor: '*MyDice' stamp: 'VeronikaLarionova 10/23/2018 23:51'!D10^ self D:10.! !'From Pharo6.0 of 13 May 2016 [Latest update: #60546] on 4 November 2018 at 5:54:49.931266 pm'!!Integer methodsFor: '*MyDice' stamp: 'VeronikaLarionova 10/23/2018 23:58'!D: aNumber"The method creates the DiceBag with self count of dice with aNumber faces"| bag |bag := Bag new.bag add: (Die withFaces: aNumber) withOccurrences: self.^ (DiceBag new dice: bag).! !'From Pharo6.0 of 13 May 2016 [Latest update: #60546] on 4 November 2018 at 5:54:49.933266 pm'!!Integer methodsFor: '*MyDice' stamp: 'VeronikaLarionova 10/23/2018 23:52'!D20^ self D:20! !'From Pharo6.0 of 13 May 2016 [Latest update: #60546] on 4 November 2018 at 5:54:49.934266 pm'!!Integer methodsFor: '*MyDice' stamp: 'VeronikaLarionova 10/23/2018 23:51'!D6^ self D:6.! !'From Pharo6.0 of 13 May 2016 [Latest update: #60546] on 4 November 2018 at 5:54:49.934266 pm'!!Integer methodsFor: '*MyDice' stamp: 'VeronikaLarionova 10/23/2018 23:50'!D4^ self D:4.! !